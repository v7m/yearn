# Работа с пулами

Канистра - https://dashboard.internetcomputer.org/canister/2ipq2-uqaaa-aaaar-qailq-cai

### Пулы, с которыми  работаем

`ckBTC_ckUSDT` (для ckBTC) \
`ckBTC_ICP` (для ckBTC, ICP) \
`ICP_ckUSDT` (для ICP) \
`ckETH_ICP` (для ICP) 


## 1. Получаем все пулы и выбираем нужные нам

Метод - `pools`. 

Из списка выбираем нужные нам по названию пула (поле `lp_token_symbol`). 

Для примера берем имя пула `ckBTC_ckUSDT`.

```
{
    tvl:472308535008
    lp_token_symbol:"ckBTC_ckUSDT"
    name:"ckBTC_ckUSDT Liquidity Pool"
    lp_fee_0:687956
    lp_fee_1:623587902
    balance_0:272927992
    balance_1:235540785270
    rolling_24h_volume:455650938092
    rolling_24h_apy:79.64
    address_0:"mxzaz-hqaaa-aaaar-qaada-cai"
    address_1:"cngnf-vqaaa-aaaar-qag4q-cai"
    rolling_24h_num_swaps:3792
    symbol_0:"ckBTC"
    symbol_1:"ckUSDT"
    pool_id:2
    price:86312.36
    chain_0:"IC"
    chain_1:"IC"
    is_removed:false
    symbol:"ckBTC_ckUSDT"
    rolling_24h_lp_fee:1030502982
    lp_fee_bps:30
}
```

### Расчет APY, APR

```
    let apr = daily_yield * 365.0 * 100;
    let apy = (1.0 + daily_yield).powf(365.0) - 1.0;
```

UPD: Короче для этой DEX, считать ничего не нужно в самом конце заметил я поле `rolling_24h_apy` - это то что нам нужно, хотя это не APY, а APR (совпадает по расчетам формулы выше), но пофиг. Данный APY за 24 часа, а значит он будет из дня в день меняться. Пока что используем это, в дальнейшем можно сохранять данные по каждому дню и высчитывать среднее за обозреваемый период. 

Формулы пригодятся для других DEX.



## 2. Вычисляем соотношение токенов для добавления в пул

В пул вносится ликвидность в двух токенах в соотношении 50/50 от стоимости.

Поле `price` из респонса выше - цена ckBTC по отношению к ckUSDT, а соответственно это и соотношение токенов, которые мы отправляем в пул.

Пример: у нас есть 1 ckBTC

Цена: 1 ckBTC = 86,312.36 ckUSDT

Половина всей ликвидноси идет в пул в ckBTC - это 0.5 ckBTC, а вторая половина в ckUSDT: 0.5 ckBTC x 86,312.36 = 43,156.18 ckUSDT

```
    // Общее количество ckBTC на кошельке
    let total_ckbtc: f64 = 1;
    // Цена: 1 ckBTC = 86,312.36 ckUSDT
    let price: f64 = 86312.36;

    // Для равновесного внесения ликвидности по стоимости
    let ckbtc_to_swap = total_ckbtc / 2.0; // == 0.5 ckBTC
    let ckbtc_to_keep = total_ckbtc - ckbtc_to_swap; // == 0.5 ckBTC
    let ckusdt_received = ckbtc_to_swap * price; // == 43,156.18 ckUSDT
```
И того: в пул нужно внести 0.5 ckBTC и 43,156.18 ckUSDT из имеющихся у нас 1 ckBTC. Для этого делаем `swap` половины в ckUSDT.

### Вариант второй расчета (swap_amounts)
Второй вариант это вызвать функцию `swap_amounts(token0, amount, token1)`, где `token1` - токен который мы меняем, `amount` - сумма которую мы меняем (половина нашей ликвидности), `token1` - токен НА который мы меняем. Функция как бы эмулирует своп.

Пример параметров:

```
    [
        "IC.mxzaz-hqaaa-aaaar-qaada-cai",
        50000000n,
        "IC.cngnf-vqaaa-aaaar-qag4q-cai"
    ]
```

Внутри респонса поле `receive_amount` - колличество токенов, которые мы получим в результате свопа.

### Третий вариант расчета (add_liquidity_amounts)

Так же можно вызывть функцию add_liquidity_amounts(token0, amount, token1), где `amount` - колличество вносимого token0 (0,5 ckBTC в нашем случае). 

Параметры:

```
    [
        "IC.ckBTC",
        50000000n,
        "IC.ckUSDT"
    ]
```

В респонсе в поле `amount_1` мы получим необходимую сумму второго токена для внесения в пул.


## 3. Делаем `swap` 50% ликвидности 

Метод - `swap_amounts`

`swap_amounts(receive_token, pay_amount, pay_token)`

Пример параметров:

```
    [
        "IC.ryjl3-tyaaa-aaaaa-aaaba-cai",
        1000000n,
        "IC.mxzaz-hqaaa-aaaar-qaada-cai"
    ]
```

## 4. Добавляем ликвидность в пулл (add_liquidity)

Полученные после свопа токены ложим в пул.

Делаем аппрув токенов `icrc2_approve`.

Добавляем ликвидность в пул вызывая `add_liquidity(toke_0, token_1, amount_0, amount_1)`

Для нашего примера:
amount_0 - соответственно 0,5 ckBTC
amount_1 - колличество ckUSDT, которое мы вычеслили в пункте 2.

В респонсе мы получаем `request_id` (тип `AddLiquidity`) - 765054n.

 

Можем получить инфу по нашей позиции вызвав `requests(request_id)`.
В респонсе есть поле `add_lp_token_amount` - это колличество наших LP токенов, которые мы получили в замен на нашу ликведность. Эти токены предстваляют нашу долю в пуле. Это полу нужно будет где-то сохранить, эта величина нам будет нужна при withdraw.

Метод `user_balances(w6ats-i6cjn-rebnv-bujzp-s6z7i-7sh3f-kgg3h-7kqzj-vckmt-dinb6-bae)` вернет нам списон наших LP позиций (пулов в которые мы добавили ликвидность) с инфой по каждой.


## 5. Withdraw ликвидности из пула

Метод `remove_liquidity_amounts(token0, token1, lpAmount)` вернет нам инфу по колличеству наших возвращаемых токенов взамен на колличество LP токенов lpAmount, которые мы получили при добавлении ликвидности в пул ранее.
Поле `remove_lp_token_amount` - это то колличество LP токенов (нашей доли в пуле), которые мы можем обменять обратно на наши токены из пула.


Чтобы достать ликвидность, вызываем метод `remove_liquidity_async(token0, token1, lpAmount)`. Колличество ликвидности, которое мы снимаем регулируется lpAmount - колличество наших LP токенов, значение это мы получили при добавлении ликвидности. Чтобы вернуть всю ликвидность - нужно отдать все LP токены.

В респонсе мы так же получаем request_id (тип `RemoveLiquidity`), можем получить инфу: `requests(request_id)`. В респонсе этого метода так же есть такие поля как `lp_fee_0` и `lp_fee_1` - это значение коммисий для каждого токена, которую мы заработали.

Как я понимаю, все коммисионные нам возвращаются вместе с основной ликвидностью, я не нашел ни в интерфейсе, ни в смарт контракте как отдельно управлять комиссиями.

После того, как мы молучили токены обратно, делаем swap второго токена на наш изначальный (ckBTC). Теперь вся ликвидность у нас в изначальном токене.

